#!/usr/bin/env bash
#===============================================================================
#
#   Script: OSC Semsumo Session Script Generator
#   Version: 2.0.0
#   Date: 2025-04-08
#   Author: Kenan Pelit
#   Repository: https://github.com/kenanpelit/nixosc
#   Description: Generates session management scripts for different profiles using Semsumo.
#                Creates executable scripts for each profile based on profiles defined in sem/config.json.
#                Uses the vpn setting from each profile.
#
#   Features:
#   - Generates profile-specific session management scripts
#   - Supports secure/bypass VPN modes
#   - Automatic script generation based on config.json
#   - Creates organized script directory structure
#   - Built-in validation and error handling
#   - Progress tracking and detailed logging
#
#   License: MIT
#
#===============================================================================

# Error handling
set -euo pipefail
IFS=$'\n\t'

# Base configuration
readonly CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/sem/config.json"
readonly SCRIPTS_DIR="$HOME/.nixosc/modules/home/system/scripts/start"
readonly SEMSUMO="semsumo"
readonly TMP_DIR="/tmp/sem"

# Color definitions
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color

# Default options
VERBOSE=0

# Helper functions
log_info() {
	echo -e "${BLUE}INFO:${NC} $1"
}

log_success() {
	echo -e "${GREEN}âœ“${NC} $1"
}

log_warning() {
	echo -e "${YELLOW}WARNING:${NC} $1"
}

log_error() {
	echo -e "${RED}ERROR:${NC} $1" >&2
}

log_verbose() {
	if [[ $VERBOSE -eq 1 ]]; then
		echo -e "${CYAN}VERBOSE:${NC} $1"
	fi
}

show_help() {
	cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Generate session management scripts for Semsumo profiles.

Options:
  -h, --help     Show this help message and exit
  -v, --verbose  Enable verbose output
  -c, --config   Specify an alternative config file location
  -o, --output   Specify an alternative output directory

Example:
  $(basename "$0") --verbose
  $(basename "$0") --config ~/custom-config.json --output ~/scripts

EOF
}

create_script() {
	local profile=$1
	local vpn_mode=$2
	local script_path="$SCRIPTS_DIR/start-${profile,,}.sh"

	log_verbose "Creating script: $script_path for profile $profile with VPN mode: $vpn_mode"

	# Create script content with improved comments and structure
	cat >"$script_path" <<EOF
#!/usr/bin/env bash
#===============================================================================
# Generated script for $profile
# Generated on: $(date '+%Y-%m-%d %H:%M:%S')
# VPN Mode: $vpn_mode
# Do not edit manually - this file is automatically generated
#===============================================================================

# Error handling
set -euo pipefail

# Environment setup
export TMPDIR="$TMP_DIR"

# Start session with Semsumo
$SEMSUMO start "$profile" "$vpn_mode"

# Exit successfully
exit 0
EOF

	# Make script executable and set proper permissions
	chmod 755 "$script_path"
	log_success "Created: start-${profile,,}.sh"
}

check_dependencies() {
	local missing_deps=0

	# Check for required commands
	for cmd in jq "$SEMSUMO" mkdir chmod; do
		if ! command -v "$cmd" >/dev/null 2>&1; then
			log_error "Required command not found: $cmd"
			missing_deps=1
		else
			log_verbose "Found required command: $cmd"
		fi
	done

	if [[ $missing_deps -eq 1 ]]; then
		log_error "Please install missing dependencies and try again."
		exit 1
	fi
}

validate_config() {
	if [[ ! -f "$CONFIG_FILE" ]]; then
		log_error "Configuration file not found at: $CONFIG_FILE"
		exit 1
	fi

	# Check if config is valid JSON
	if ! jq empty "$CONFIG_FILE" 2>/dev/null; then
		log_error "Configuration file is not valid JSON: $CONFIG_FILE"
		exit 1
	fi

	# Check if config contains sessions field
	if ! jq -e '.sessions' "$CONFIG_FILE" >/dev/null 2>&1; then
		log_error "Configuration file must contain a 'sessions' field"
		exit 1
	fi

	# Check if there are any profiles defined
	local profile_count
	profile_count=$(jq '.sessions | keys | length' "$CONFIG_FILE")

	if [[ $profile_count -eq 0 ]]; then
		log_warning "No profiles found in configuration file"
		return 1
	else
		log_info "Found $profile_count profile(s) in configuration file"
		return 0
	fi
}

process_profiles() {
	local profiles
	local total_profiles
	local current=0

	# Get all profile names from config in one call
	profiles=$(jq -r '.sessions | keys[]' "$CONFIG_FILE")
	total_profiles=$(echo "$profiles" | wc -l)

	echo "----------------------------------------"
	log_info "Starting script generation for $total_profiles profile(s)..."

	# Process each profile and generate scripts based on VPN mode
	while IFS= read -r profile; do
		current=$((current + 1))

		# Skip empty profiles (shouldn't happen with proper JSON)
		if [[ -z "$profile" ]]; then
			continue
		fi

		# Show progress
		log_info "[$current/$total_profiles] Processing profile: $profile"

		# Validate profile name (avoid directory traversal)
		if [[ "$profile" =~ [\/\\] ]]; then
			log_error "Invalid profile name (contains path characters): $profile"
			continue
		fi

		# Get VPN mode from config - convert old vpn_mode if needed
		local vpn_mode

		# First try the new 'vpn' field
		vpn_mode=$(jq -r ".sessions.\"$profile\".vpn // \"\"" "$CONFIG_FILE")

		# If empty, try legacy vpn_mode and convert
		if [[ -z "$vpn_mode" ]]; then
			local legacy_mode
			legacy_mode=$(jq -r ".sessions.\"$profile\".vpn_mode // \"default\"" "$CONFIG_FILE")

			case "$legacy_mode" in
			"never")
				vpn_mode="bypass"
				;;
			"always")
				vpn_mode="secure"
				;;
			*)
				vpn_mode="secure" # Default to secure if not specified or invalid
				;;
			esac

			log_verbose "Converting legacy vpn_mode '$legacy_mode' to '$vpn_mode' for profile $profile"
		fi

		# Generate script with the correct VPN mode
		create_script "$profile" "$vpn_mode"

		echo ""
	done <<<"$profiles"

	echo "----------------------------------------"
	log_success "Script generation complete! Generated $total_profiles scripts."
}

# Parse command line arguments
parse_args() {
	while [[ $# -gt 0 ]]; do
		case $1 in
		-h | --help)
			show_help
			exit 0
			;;
		-v | --verbose)
			VERBOSE=1
			shift
			;;
		-c | --config)
			CONFIG_FILE="$2"
			shift 2
			;;
		-o | --output)
			SCRIPTS_DIR="$2"
			shift 2
			;;
		*)
			log_error "Unknown option: $1"
			show_help
			exit 1
			;;
		esac
	done
}

main() {
	# Parse command-line arguments
	parse_args "$@"

	# Check dependencies
	check_dependencies

	# Validate configuration file
	validate_config

	# Create necessary directories with proper permissions
	mkdir -p "$SCRIPTS_DIR"
	if [[ ! -d "$TMP_DIR" ]]; then
		mkdir -p "$TMP_DIR"
		chmod 700 "$TMP_DIR"
		log_verbose "Created temporary directory: $TMP_DIR"
	fi

	# Process profiles and generate scripts
	process_profiles

	# Show usage examples
	echo ""
	log_info "Usage examples:"

	# Get first profile for example
	local example_profile
	example_profile=$(jq -r '.sessions | keys[0] // "example"' "$CONFIG_FILE")
	example_profile=${example_profile,,}

	echo "  $SCRIPTS_DIR/start-$example_profile.sh"
}

# Execute main function with all arguments
main "$@"
